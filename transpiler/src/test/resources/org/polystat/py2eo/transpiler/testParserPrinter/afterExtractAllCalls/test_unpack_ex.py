xdoctests = "\n\nUnpack tuple\n\n    >>> t = (1, 2, 3)\n    >>> a, *b, c = t\n    >>> a == 1 and b == [2] and c == 3\n    True\n\nUnpack list\n\n    >>> l = [4, 5, 6]\n    >>> a, *b = l\n    >>> a == 4 and b == [5, 6]\n    True\n\nUnpack implied tuple\n\n    >>> *a, = 7, 8, 9\n    >>> a == [7, 8, 9]\n    True\n\nUnpack string... fun!\n\n    >>> a, *b = 'one'\n    >>> a == 'o' and b == ['n', 'e']\n    True\n\nUnpack long sequence\n\n    >>> a, b, c, *d, e, f, g = range(10)\n    >>> (a, b, c, d, e, f, g) == (0, 1, 2, [3, 4, 5, 6], 7, 8, 9)\n    True\n\nUnpack short sequence\n\n    >>> a, *b, c = (1, 2)\n    >>> a == 1 and c == 2 and b == []\n    True\n\nUnpack generic sequence\n\n    >>> class Seq:\n    ...     def __getitem__(self, i):\n    ...         if i >= 0 and i < 3: return i\n    ...         raise IndexError\n    ...\n    >>> a, *b = Seq()\n    >>> a == 0 and b == [1, 2]\n    True\n\nUnpack in for statement\n\n    >>> for a, *b, c in [(1,2,3), (4,5,6,7)]:\n    ...     print(a, b, c)\n    ...\n    1 [2] 3\n    4 [5, 6] 7\n\nUnpack in list\n\n    >>> [a, *b, c] = range(5)\n    >>> a == 0 and b == [1, 2, 3] and c == 4\n    True\n\nMultiple targets\n\n    >>> a, *b, c = *d, e = range(5)\n    >>> a == 0 and b == [1, 2, 3] and c == 4 and d == [0, 1, 2, 3] and e == 4\n    True\n\nAssignment unpacking\n\n    >>> a, b, *c = range(5)\n    >>> a, b, c\n    (0, 1, [2, 3, 4])\n    >>> *a, b, c = a, b, *c\n    >>> a, b, c\n    ([0, 1, 2], 3, 4)\n\nSet display element unpacking\n\n    >>> a = [1, 2, 3]\n    >>> sorted({1, *a, 0, 4})\n    [0, 1, 2, 3, 4]\n\n    >>> {1, *1, 0, 4}\n    Traceback (most recent call last):\n      ...\n    TypeError: 'int' object is not iterable\n\nDict display element unpacking\n\n    >>> kwds = {'z': 0, 'w': 12}\n    >>> sorted({'x': 1, 'y': 2, **kwds}.items())\n    [('w', 12), ('x', 1), ('y', 2), ('z', 0)]\n\n    >>> sorted({**{'x': 1}, 'y': 2, **{'z': 3}}.items())\n    [('x', 1), ('y', 2), ('z', 3)]\n\n    >>> sorted({**{'x': 1}, 'y': 2, **{'x': 3}}.items())\n    [('x', 3), ('y', 2)]\n\n    >>> sorted({**{'x': 1}, **{'x': 3}, 'x': 4}.items())\n    [('x', 4)]\n\n    >>> {**{}}\n    {}\n\n    >>> a = {}\n    >>> {**a}[0] = 1\n    >>> a\n    {}\n\n    >>> {**1}\n    Traceback (most recent call last):\n    ...\n    TypeError: 'int' object is not a mapping\n\n    >>> {**[]}\n    Traceback (most recent call last):\n    ...\n    TypeError: 'list' object is not a mapping\n\n    >>> len(eval(\"{\" + \", \".join(\"**{{{}: {}}}\".format(i, i)\n    ...                          for i in range(1000)) + \"}\"))\n    1000\n\n    >>> {0:1, **{0:2}, 0:3, 0:4}\n    {0: 4}\n\nList comprehension element unpacking\n\n    >>> a, b, c = [0, 1, 2], 3, 4\n    >>> [*a, b, c]\n    [0, 1, 2, 3, 4]\n\n    >>> l = [a, (3, 4), {5}, {6: None}, (i for i in range(7, 10))]\n    >>> [*item for item in l]\n    Traceback (most recent call last):\n    ...\n    SyntaxError: iterable unpacking cannot be used in comprehension\n\n    >>> [*[0, 1] for i in range(10)]\n    Traceback (most recent call last):\n    ...\n    SyntaxError: iterable unpacking cannot be used in comprehension\n\n    >>> [*'a' for i in range(10)]\n    Traceback (most recent call last):\n    ...\n    SyntaxError: iterable unpacking cannot be used in comprehension\n\n    >>> [*[] for i in range(10)]\n    Traceback (most recent call last):\n    ...\n    SyntaxError: iterable unpacking cannot be used in comprehension\n\nGenerator expression in function arguments\n\n    >>> list(*x for x in (range(5) for i in range(3)))\n    Traceback (most recent call last):\n    ...\n        list(*x for x in (range(5) for i in range(3)))\n                  ^\n    SyntaxError: invalid syntax\n\n    >>> dict(**x for x in [{1:2}])\n    Traceback (most recent call last):\n    ...\n        dict(**x for x in [{1:2}])\n                   ^\n    SyntaxError: invalid syntax\n\nIterable argument unpacking\n\n    >>> print(*[1], *[2], 3)\n    1 2 3\n\nMake sure that they don't corrupt the passed-in dicts.\n\n    >>> def f(x, y):\n    ...     print(x, y)\n    ...\n    >>> original_dict = {'x': 1}\n    >>> f(**original_dict, y=2)\n    1 2\n    >>> original_dict\n    {'x': 1}\n\nNow for some failures\n\nMake sure the raised errors are right for keyword argument unpackings\n\n    >>> from collections.abc import MutableMapping\n    >>> class CrazyDict(MutableMapping):\n    ...     def __init__(self):\n    ...         self.d = {}\n    ...\n    ...     def __iter__(self):\n    ...         for x in self.d.__iter__():\n    ...             if x == 'c':\n    ...                 self.d['z'] = 10\n    ...             yield x\n    ...\n    ...     def __getitem__(self, k):\n    ...         return self.d[k]\n    ...\n    ...     def __len__(self):\n    ...         return len(self.d)\n    ...\n    ...     def __setitem__(self, k, v):\n    ...         self.d[k] = v\n    ...\n    ...     def __delitem__(self, k):\n    ...         del self.d[k]\n    ...\n    >>> d = CrazyDict()\n    >>> d.d = {chr(ord('a') + x): x for x in range(5)}\n    >>> e = {**d}\n    Traceback (most recent call last):\n    ...\n    RuntimeError: dictionary changed size during iteration\n\n    >>> d.d = {chr(ord('a') + x): x for x in range(5)}\n    >>> def f(**kwargs): print(kwargs)\n    >>> f(**d)\n    Traceback (most recent call last):\n    ...\n    RuntimeError: dictionary changed size during iteration\n\nOverridden parameters\n\n    >>> f(x=5, **{'x': 3}, y=2)\n    Traceback (most recent call last):\n      ...\n    TypeError: f() got multiple values for keyword argument 'x'\n\n    >>> f(**{'x': 3}, x=5, y=2)\n    Traceback (most recent call last):\n      ...\n    TypeError: f() got multiple values for keyword argument 'x'\n\n    >>> f(**{'x': 3}, **{'x': 5}, y=2)\n    Traceback (most recent call last):\n      ...\n    TypeError: f() got multiple values for keyword argument 'x'\n\n    >>> f(x=5, **{'x': 3}, **{'x': 2})\n    Traceback (most recent call last):\n      ...\n    TypeError: f() got multiple values for keyword argument 'x'\n\n    >>> f(**{1: 3}, **{1: 5})\n    Traceback (most recent call last):\n      ...\n    TypeError: f() keywords must be strings\n\nUnpacking non-sequence\n\n    >>> a, *b = 7\n    Traceback (most recent call last):\n      ...\n    TypeError: cannot unpack non-iterable int object\n\nUnpacking sequence too short\n\n    >>> a, *b, c, d, e = Seq()\n    Traceback (most recent call last):\n      ...\n    ValueError: not enough values to unpack (expected at least 4, got 3)\n\nUnpacking sequence too short and target appears last\n\n    >>> a, b, c, d, *e = Seq()\n    Traceback (most recent call last):\n      ...\n    ValueError: not enough values to unpack (expected at least 4, got 3)\n\nUnpacking a sequence where the test for too long raises a different kind of\nerror\n\n    >>> class BozoError(Exception):\n    ...     pass\n    ...\n    >>> class BadSeq:\n    ...     def __getitem__(self, i):\n    ...         if i >= 0 and i < 3:\n    ...             return i\n    ...         elif i == 3:\n    ...             raise BozoError\n    ...         else:\n    ...             raise IndexError\n    ...\n\nTrigger code while not expecting an IndexError (unpack sequence too long, wrong\nerror)\n\n    >>> a, *b, c, d, e = BadSeq()\n    Traceback (most recent call last):\n      ...\n    test.test_unpack_ex.BozoError\n\nNow some general starred expressions (all fail).\n\n    >>> a, *b, c, *d, e = range(10) # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    SyntaxError: two starred expressions in assignment\n\n    >>> [*b, *c] = range(10) # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    SyntaxError: two starred expressions in assignment\n\n    >>> *a = range(10) # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    SyntaxError: starred assignment target must be in a list or tuple\n\n    >>> *a # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    SyntaxError: can't use starred expression here\n\n    >>> *1 # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    SyntaxError: can't use starred expression here\n\n    >>> x = *a # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    SyntaxError: can't use starred expression here\n\nSome size constraints (all fail.)\n\n    >>> s = \", \".join(\"a%d\" % i for i in range(1<<8)) + \", *rest = range(1<<8 + 1)\"\n    >>> compile(s, 'test', 'exec') # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n     ...\n    SyntaxError: too many expressions in star-unpacking assignment\n\n    >>> s = \", \".join(\"a%d\" % i for i in range(1<<8 + 1)) + \", *rest = range(1<<8 + 2)\"\n    >>> compile(s, 'test', 'exec') # doctest:+ELLIPSIS\n    Traceback (most recent call last):\n     ...\n    SyntaxError: too many expressions in star-unpacking assignment\n\n(there is an additional limit, on the number of expressions after the\n'*rest', but it's 1<<24 and testing it takes too much memory.)\n\n" # 3:0-3:8648
x__test__ = {"doctests" : xdoctests} # 357:0-357:33
def xtest_main(xverbose = False): # 359:0-364:-1
    from xtest import xsupport # 360:21-360:27
    from xtest import xtest_unpack_ex # 361:21-361:34
    e0 = xsupport.xrun_doctest # 362:4-362:22
    lhs0 = xtest_unpack_ex # 362:24-362:37
    lhs1 = xverbose # 362:40-362:46
    e1 = e0(lhs0, lhs1) # 362:4-362:47
e3 = (x__name__ == "__main__") # 364:3-364:24
if (e3): # 364:26-366:-1 
    e2 = xtest_main(xverbose=True) # 365:4-365:26
else: # 364:0-366:-1
    pass # 364:0-366:-1