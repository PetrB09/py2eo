+package preface
+alias cage org.eolang.gray.cage
+alias goto org.eolang.gray.goto
+alias xStopIteration preface.xStopIteration
+alias mkCopy preface.mkCopy
+alias pyint preface.pyint
+alias pybool preface.pybool
+alias return preface.return
+alias stdout org.eolang.io.stdout
+alias sprintf org.eolang.txt.sprintf

[] > xmyArray
  pyint 10 > x__id__
  [initValue] > apply
    [stackUp] > @
      cage result > pResult
      [] > result
        cage initValue > value
        xmyArray > x__class__
        [] > xlength
          [self] > apply
            [stackUp] > @
              seq > @
                stackUp.forward (return (pyint (self.value.length)))
                123
        [i] > get
          (value.get (i.value)) > @
        [] > xappend
          [self x] > apply
            [stackUp] > @
              seq > @
                mkCopy (x.value) > tmpx
                mkCopy (self.value) > tmp
                self.value.write (tmp.copy.with (tmpx.copy))
                stackUp.forward (return 0)
                123
        [x] > eq
          ((x.x__class__.x__id__.eq x__id__).and (pybool (value.eq (x.value)))) > @
        [] > x__contains__
          [self elt] > apply
            [stackUp] > @
              seq > result
                stdout (sprintf "len = %d\n" (self.value.length))
                self.value.reduce
                  FALSE
                  [acc item]
                    seq > @
                      stdout (sprintf "acc = %b, item = %d, elt = %d\n" acc item elt)
                      acc.or ((elt.eq item).value)
              seq > @
                stdout (sprintf "len = %d\n" (self.value.length))
                stackUp.forward (return (pybool result))
                123
        [] > iter
          memory 0 > curPos
          [] > x__next__
            [self] > apply
              [stackUp] > @
                memory (self.curPos) > pos
                seq > @
                  pos.write (self.curPos)
                  self.curPos.write (pos.add 1)
                  if.
                    pos.eq (value.length)
                    stackUp.forward ((goto (xStopIteration.apply.@)).result)
                    stackUp.forward (return (value.get (pos)))
                  123
        [] > x__iter__
          [self] > apply
            [stackUp] > @
              stackUp.forward (return iter) > @

      seq > @
        pResult.write result
        stackUp.forward (return pResult)
