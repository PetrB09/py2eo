+package preface
+alias pyfloat preface.pyfloat

[value] > pyint
  # Absolute value of $ (i.e., with no sign)
  [] > abs
    pyint (^.value.abs) > @

  # Sum of $ and x
  [x] > add
    if. > @
      x.class.eq "float"
      ^.float.add x
      pyint (^.value.add x.value)

  # AND
  [x] > and
    pyint (^.bool.and x.bool).as-int > @

  # Converts this to bool
  [] > bool
    ^.value.neq 0 > @

  # Ceiling of $
  [] > ceil
    ^ > @

  # Class name of $
  [] > class
    "int" > @

  # Tests that $ = x
  [x] > eq
    if. > @
      x.class.eq "float"
      ^.float.eq x
      ^.value.eq x.value

  # Converts this to float
  [] > float
    pyfloat (^.value.as-float) > @

  # Floor of $
  [] > floor
    ^ > @

  # Quotient of the division of $ by x
  [x] > floordiv
    if. > @
      x.class.eq "float"
      ^.float.div x
      pyint (^.value.div x.value)

  # Tests that $ â‰¥ x
  [x] > ge
    if. > @
      x.class.eq "float"
      ^.float.ge x
      ^.value.geq x.value

  # Tests that $ > x
  [x] > gt
    if. > @
      x.class.eq "float"
      ^.float.gt x
      ^.value.greater x.value

  # Converts this to int
  [] > int
    ^ > @

  # Calculate bitwise not
  [] > invert
    pyint (^.value.as-bytes.not.as-int) > @

  # Tests that $ â‰¤ x
  [x] > le
    if. > @
      x.class.eq "float"
      ^.float.le x
      ^.value.leq x.value

  # Calculate bitwise left shift
  [x] > lshift
    pyint ((^.value.as-bytes.left x.value).as-int) > @

  # Tests that $ < x
  [x] > lt
    if. > @
      x.class.eq "float"
      ^.float.lt x
      ^.value.less x.value

  # Calculate MOD
  [x] > mod
    pyint (^.value.mod x.value) > @

  # Multiplication of $ and x
  [x] > mul
    if. > @
      x.class.eq "float"
      ^.float.mul x
      pyint (^.value.mul x.value)

  # Tests that $ â‰  x
  [x] > ne
    if. > @
      x.class.eq "float"
      ^.float.ne x
      ^.value.neq x.value

  # Negation of $
  [] > neg
    pyint (^.value.neg) > @

  # NOT
  [] > not
    pyint (^.bool.not.as-int) > @

  # OR
  [x] > or
    pyint ((^.bool.or x.bool).as-int) > @

  # x'th power of $
  [x] > pow
    if. > @
      x.class.eq "float"
      ^.float.pow x
      pyint (^.value.pow x.value)

  # Round $
  [] > round
    ^ > @

  # Calculate bitwise right shift
  [x] > rshift
    pyint ((^.value.as-bytes.right x.value).as-int) > @

  # Converts this to string
  [] > str
    ^.value.as-string > @

  # Difference between $ and x
  [x] > sub
    if. > @
      x.class.eq "float"
      ^.float.sub x
      pyint (^.value.sub x.value)

  # Truncate $
  [] > trunc
    ^ > @
